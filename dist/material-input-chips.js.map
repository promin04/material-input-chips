{"version":3,"file":"material-input-chips.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 04a0bf185c594eea3708","webpack:///external \"react\"","webpack:///external \"prop-types\"","webpack:///external \"material-ui/styles\"","webpack:///external \"classnames\"","webpack:///src/MaterialChips/index.js","webpack:///external \"material-ui/Input\"","webpack:///external \"material-ui/Form\"","webpack:///./node_modules/fuse.js/dist/fuse.js","webpack:///./node_modules/copy-to-clipboard/index.js","webpack:///./node_modules/toggle-selection/index.js","webpack:///src/MaterialChips/Chip.js","webpack:///external \"material-ui/Chip\"","webpack:///src/MaterialChips/Options.js","webpack:///external \"material-ui/Paper\"","webpack:///external \"material-ui/Menu\"","webpack:///./node_modules/deepmerge/dist/es.js","webpack:///src/MaterialChips/helpers.js","webpack:///src/MaterialChips/styles.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"prop-types\"), require(\"material-ui/styles\"), require(\"classnames\"), require(\"material-ui/Input\"), require(\"material-ui/Form\"), require(\"material-ui/Chip\"), require(\"material-ui/Paper\"), require(\"material-ui/Menu\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"prop-types\", \"material-ui/styles\", \"classnames\", \"material-ui/Input\", \"material-ui/Form\", \"material-ui/Chip\", \"material-ui/Paper\", \"material-ui/Menu\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"react\"), require(\"prop-types\"), require(\"material-ui/styles\"), require(\"classnames\"), require(\"material-ui/Input\"), require(\"material-ui/Form\"), require(\"material-ui/Chip\"), require(\"material-ui/Paper\"), require(\"material-ui/Menu\")) : factory(root[\"react\"], root[\"prop-types\"], root[\"material-ui/styles\"], root[\"classnames\"], root[\"material-ui/Input\"], root[\"material-ui/Form\"], root[\"material-ui/Chip\"], root[\"material-ui/Paper\"], root[\"material-ui/Menu\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_11__, __WEBPACK_EXTERNAL_MODULE_13__, __WEBPACK_EXTERNAL_MODULE_14__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 04a0bf185c594eea3708","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"prop-types\"\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"material-ui/styles\"\n// module id = 2\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"classnames\"\n// module id = 3\n// module chunks = 0","import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport Input, { InputLabel } from 'material-ui/Input'\r\nimport { FormControl, FormHelperText } from 'material-ui/Form'\r\nimport { withStyles } from 'material-ui/styles'\r\nimport cx from 'classnames'\r\nimport Fuse from 'fuse.js'\r\nimport copy from 'copy-to-clipboard'\r\n\r\nimport Chip from './Chip'\r\nimport createOptions from './Options'\r\nimport { TYPES, acceptedCharCodes, validate, mimicFuseSearch, keysWatcher } from './helpers'\r\nimport styles from './styles'\r\n\r\n\r\n/**\r\n * material-ui based, chips autocomplete\r\n *\r\n * @version 1.4.1\r\n * @author [Rodrigo Nehring](https://github.com/rodrigonehring)\r\n*/\r\nclass MaterialChips extends Component {\r\n  static propTypes = {\r\n    /** disable delete button on chips */\r\n    chipsDisabled: PropTypes.bool,\r\n\r\n    /** Classes from material-ui withStyles() */\r\n    classes: PropTypes.object,\r\n\r\n    /** clear input text after add an item */\r\n    clearAfterAdd: PropTypes.bool,\r\n\r\n    /** react component to render a chip */\r\n    chipComponent: PropTypes.func,\r\n\r\n    /** Disable input */\r\n    disabled: PropTypes.bool,\r\n\r\n    /** Custom fields names */\r\n    fields: PropTypes.shape({ label: PropTypes.string, value: PropTypes.string }),\r\n\r\n    /** To mimic a select field */\r\n    fixedOptions: PropTypes.bool,\r\n\r\n    /** disable input field */\r\n    inputDisabled: PropTypes.bool,\r\n\r\n    /** Props wich will be passed directly to component */\r\n    // inputProps: PropTypes.object,\r\n\r\n    /** label for input */\r\n    label: PropTypes.string,\r\n\r\n    /** Should return a new chip, receive fields filled   */\r\n    makeChip: PropTypes.func,\r\n\r\n    /** Callback fired when user add or remove one chip,\r\n     * return arrayOf selected items after change  */\r\n    onChange: PropTypes.func,\r\n\r\n    /** Callback fired when user type something in input, return input string */\r\n    onSearch: PropTypes.func,\r\n\r\n    /** auto open autocomplete options on focus container */\r\n    openOnFocus: PropTypes.bool,\r\n\r\n    /** To show in autocomplete  */\r\n    options: PropTypes.arrayOf(PropTypes.object),\r\n\r\n    /** fn(theme) => ({ optionsContainer, optionsContainerOpen }) to override options styles */\r\n    optionsClasses: PropTypes.func,\r\n\r\n    /** Must receive state from props */\r\n    selected: PropTypes.arrayOf(PropTypes.object),\r\n\r\n    /** Keycodes to watch when user keydown, to fire internal add method */\r\n    submitKeyCodes: PropTypes.arrayOf(PropTypes.number),\r\n\r\n    /** Array of validators, will be executed to verify if input can be a chip */\r\n    validators: PropTypes.arrayOf(PropTypes.shape({\r\n      message: PropTypes.string, validator: PropTypes.func,\r\n    })),\r\n  }\r\n\r\n  static defaultProps = {\r\n    label: '',\r\n    openOnFocus: false,\r\n    chipsDisabled: false,\r\n    inputDisabled: false,\r\n    options: [],\r\n    submitKeyCodes: [13, 9, 191],\r\n    clearAfterAdd: true,\r\n    fields: { label: 'label', value: 'value' },\r\n    makeChip: chip => chip,\r\n    chipComponent: Chip,\r\n    selected: [],\r\n  }\r\n\r\n  state = {\r\n    containerFocus: false,\r\n    inputFocus: false,\r\n    chipFocus: null,\r\n    optionsOpen: false,\r\n    translateX: 0,\r\n    input: '',\r\n    options: [],\r\n    optionsFocus: null,\r\n  }\r\n\r\n  componentDidMount() {\r\n    document.addEventListener('mousedown', this.handleClickOutside)\r\n    this.configureFuse()\r\n  }\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    if (!this.props.disabled && nextProps.disabled) {\r\n      this.reset()\r\n    }\r\n\r\n    if (this.props.selected !== nextProps.selected || this.props.options !== nextProps.options) {\r\n      this.configureFuse(this.filterOptionsSelected(nextProps.options, nextProps.selected))\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    document.removeEventListener('mousedown', this.handleClickOutside)\r\n  }\r\n\r\n  onChange = (selected) => {\r\n    if (this.props.onChange) {\r\n      this.props.onChange(selected)\r\n    }\r\n  }\r\n\r\n  OptionsComponent = createOptions(this.props.optionsClasses)\r\n\r\n  handleKeyPress = (e) => {\r\n    const { inputFocus } = this.state\r\n\r\n    // not selected, typed \"normal\" key, then select input\r\n    if (!inputFocus && acceptedCharCodes(e.charCode)) {\r\n      this.input.focus()\r\n    }\r\n  }\r\n\r\n  haveOptionsKeys = e => []\r\n    .concat(TYPES.UP).concat(TYPES.DOWN).concat(this.props.submitKeyCodes)\r\n    .includes(e.keyCode)\r\n\r\n  handleOptionsKeys = (e) => {\r\n    e.preventDefault()\r\n    const { optionsFocus, options } = this.state\r\n    let nextPosition\r\n\r\n    if (TYPES.UP.includes(e.keyCode)) {\r\n      if (optionsFocus > 0) {\r\n        nextPosition = optionsFocus - 1\r\n      } else {\r\n        nextPosition = null\r\n      }\r\n    } else if (TYPES.DOWN.concat(TYPES.TAB).includes(e.keyCode)) {\r\n      if (optionsFocus === null) {\r\n        nextPosition = 0\r\n      } else if (optionsFocus !== options.length - 1) {\r\n        nextPosition = optionsFocus + 1\r\n      } else {\r\n        nextPosition = null\r\n      }\r\n    } else if (this.props.submitKeyCodes.includes(e.keyCode) && typeof optionsFocus === 'number') {\r\n      this.addItemObject(options[optionsFocus].item, true)\r\n      return true\r\n    }\r\n\r\n    if (typeof nextPosition === 'number' || nextPosition === null) {\r\n      this.setState({ optionsFocus: nextPosition })\r\n      return true\r\n    }\r\n  }\r\n\r\n  handleKeyDown = (e) => {\r\n    const { inputFocus, input: inputValue, chipFocus, optionsOpen } = this.state\r\n    const { selected } = this.props\r\n\r\n    if (optionsOpen) {\r\n      // key press ESC, close options\r\n      if (TYPES.ESCAPE.includes(e.keyCode)) {\r\n        return this.setState({\r\n          optionsOpen: false,\r\n          optionsFocus: null,\r\n        })\r\n      }\r\n\r\n      if (this.haveOptionsKeys(e)) {\r\n        const shouldStop = this.handleOptionsKeys(e)\r\n        if (shouldStop) {\r\n          return\r\n        }\r\n      }\r\n    }\r\n\r\n    if (inputFocus) {\r\n      // input not empty\r\n      if (inputValue.length > 0) {\r\n        // verify keycode submission type\r\n        if (this.props.submitKeyCodes.includes(e.keyCode)) {\r\n          this.addItem(inputValue)\r\n          e.preventDefault()\r\n        }\r\n      } else {\r\n        // ser for um TAB, limpa algumas coisas\r\n        if (TYPES.TAB.includes(e.keyCode)) {\r\n          return this.setState({\r\n            chipFocus: null,\r\n            inputFocus: false,\r\n            containerFocus: false,\r\n          })\r\n        }\r\n\r\n        // se for um BACKSPACE, deleta última item da lista\r\n        if (TYPES.BACKSPACE.includes(e.keyCode) && selected.length > 0) {\r\n          return this.deleteItem(selected[selected.length - 1])()\r\n        }\r\n\r\n        if (TYPES.LEFT.includes(e.keyCode)) {\r\n          e.preventDefault()\r\n          this.focusChip(selected.length - 1)\r\n        }\r\n      }\r\n    } else if (!inputFocus && chipFocus !== null) {\r\n      // movimentar focus ao apartar left right\r\n      if (TYPES.RIGHT.includes(e.keyCode)) {\r\n        e.preventDefault()\r\n        if (selected.length === (chipFocus + 1)) {\r\n          this.input.focus()\r\n        } else {\r\n          this.focusChip(chipFocus + 1)\r\n        }\r\n      }\r\n\r\n      // movimentar focus ao apartar left right\r\n      if (TYPES.LEFT.includes(e.keyCode) && chipFocus !== 0) {\r\n        e.preventDefault()\r\n        this.focusChip(chipFocus - 1)\r\n      }\r\n\r\n      // deleta item selecionado\r\n      if (TYPES.DELETE_CODES.includes(e.keyCode)) {\r\n        this.deleteItem(selected[chipFocus])()\r\n\r\n        // seleciona anterior\r\n        if (selected.length > 1 && chipFocus !== 0) {\r\n          this.focusChip(chipFocus - 1)\r\n        } else if (chipFocus === 0 && selected.length > 1) {\r\n          this.input.focus()\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  * Handle search stuff, with fuse.js\r\n  */\r\n  configureFuse = (list = this.props.options) => {\r\n    if (this.props.fixedOptions) {\r\n      return this.setState({\r\n        options: mimicFuseSearch(list),\r\n      })\r\n    }\r\n\r\n    this.fuse = new Fuse(list, {\r\n      shouldSort: true,\r\n      threshold: 0.4,\r\n      includeScore: true,\r\n      maxPatternLength: 32,\r\n      minMatchCharLength: 3,\r\n      includeMatches: true,\r\n      matchAllTokens: true,\r\n      distance: 100,\r\n      keys: Object.values(this.props.fields),\r\n      location: 0,\r\n    })\r\n\r\n    this.search()\r\n  }\r\n\r\n  search = (value = this.state.input) => {\r\n    const { onSearch } = this.props\r\n    const options = this.fuse.search(value)\r\n\r\n    this.setState({ options, optionsOpen: options.length > 0 })\r\n\r\n    if (onSearch) {\r\n      onSearch(value)\r\n    }\r\n  }\r\n\r\n  // reset when click outside component\r\n  handleClickOutside = (event) => {\r\n    if (this.containerRef && !this.containerRef.contains(event.target)) {\r\n      this.reset()\r\n    }\r\n  }\r\n\r\n  reset = () => {\r\n    setTimeout(() => {\r\n      this.setState({\r\n        error: false,\r\n        containerFocus: false,\r\n        inputFocus: false,\r\n        chipFocus: null,\r\n        optionsOpen: false,\r\n      })\r\n    })\r\n  }\r\n\r\n  handleCopy = (e) => {\r\n    const { selected } = this.props\r\n    const { chipFocus } = this.state\r\n\r\n    if (chipFocus !== null) {\r\n      e.preventDefault()\r\n      const currentChip = selected[chipFocus]\r\n      copy(JSON.stringify(currentChip))\r\n      this.input.focus()\r\n      this.focusChip(chipFocus)\r\n    }\r\n  }\r\n\r\n  handlePaste = (e) => {\r\n    const { selected, fields, disabled } = this.props\r\n    const clipboard = e.clipboardData.getData('Text')\r\n\r\n    if (disabled || !this.state.containerFocus) {\r\n      return\r\n    }\r\n\r\n    try {\r\n      const item = JSON.parse(clipboard)\r\n\r\n      if (!item[fields.value]) {\r\n        throw new Error(`Don't contain ${fields.value}`)\r\n      }\r\n\r\n      const exist = selected.find(i => i[fields.value] === item[fields.value])\r\n\r\n      if (exist) {\r\n        e.preventDefault()\r\n        this.setState(state => ({ input: state.input + item[fields.value] }))\r\n        return\r\n      }\r\n\r\n      e.preventDefault()\r\n      this.addItemObject(item, true)\r\n    } catch (error) {\r\n      const valid = !validate(clipboard, this.props.validators, this.props.selected)\r\n\r\n      if (valid) {\r\n        e.preventDefault()\r\n        this.addItem(clipboard)\r\n      }\r\n    }\r\n  }\r\n\r\n  handleInputChange = ({ target }) => {\r\n    if (target.value.length > 3) {\r\n      this.setState({\r\n        error: null,\r\n        input: target.value,\r\n      })\r\n\r\n      this.search(target.value)\r\n\r\n      return this.input.focus()\r\n    } else if (target.value.length === 0) {\r\n      return this.setState({\r\n        error: null,\r\n        input: '',\r\n        optionsOpen: false,\r\n      })\r\n    }\r\n\r\n    this.setState({\r\n      error: null,\r\n      input: target.value,\r\n    })\r\n  }\r\n\r\n  chipRefs = {}\r\n\r\n  focusChip = (index) => {\r\n    const ref = this.chipRefs[index]\r\n    const selector = ref.querySelector(':scope [role=\"button\"]')\r\n    if (selector) {\r\n      selector.focus()\r\n    }\r\n  }\r\n\r\n  makeItem = (newValue) => {\r\n    const { fields, makeChip } = this.props\r\n\r\n    return makeChip({\r\n      [fields.value]: newValue,\r\n      [fields.label]: newValue,\r\n    })\r\n  }\r\n\r\n  addItemObject = (option, focus) => {\r\n    const { selected, clearAfterAdd } = this.props\r\n\r\n    if (clearAfterAdd) {\r\n      this.setState(\r\n        {\r\n          input: '',\r\n          optionsFocus: null,\r\n        },\r\n        () => this.onChange([...selected, option])\r\n      )\r\n    }\r\n\r\n    if (focus) {\r\n      this.input.focus()\r\n    }\r\n  }\r\n\r\n  addItem = (value) => {\r\n    const error = validate(value, this.props.validators, this.props.selected)\r\n    const item = this.makeItem(value)\r\n    const { selected, clearAfterAdd } = this.props\r\n\r\n    if (error) {\r\n      return this.setState({ error })\r\n    }\r\n\r\n    this.setState(\r\n      state => ({\r\n        error,\r\n        input: clearAfterAdd ? '' : state.input,\r\n      }),\r\n      () => {\r\n        this.onChange([...selected, item])\r\n        setTimeout(() => this.alignInput(), 100)\r\n      }\r\n    )\r\n  }\r\n\r\n  deleteItem = chip => () => {\r\n    const { selected, fields } = this.props\r\n\r\n    this.setState(\r\n      { chipFocus: null },\r\n      () => {\r\n        this.onChange(selected.filter(item => item[fields.value] !== chip[fields.value]))\r\n        this.calculatePosition()\r\n      }\r\n    )\r\n  }\r\n\r\n  handleContainerFocus = () => {\r\n    if (!this.props.disabled) {\r\n      this.setState(state => ({\r\n        optionsOpen: state.optionsOpen || this.props.openOnFocus,\r\n        containerFocus: true,\r\n      }), () => {\r\n        if (this.state.chipFocus === null) {\r\n          return this.input.focus()\r\n        }\r\n\r\n        this.calculatePosition()\r\n      })\r\n    }\r\n  }\r\n\r\n  resetScroll = () => {\r\n    this.chipsWrapper.scrollLeft = 0\r\n  }\r\n\r\n  handleInputFocus = () => {\r\n    this.resetScroll()\r\n    this.setState({ inputFocus: true, chipFocus: null }, () => this.calculatePosition())\r\n  }\r\n\r\n  handleInputBlur = () => {\r\n    this.setState({ inputFocus: false }, () => this.calculatePosition())\r\n  }\r\n\r\n  handleContainerBlur = () => {\r\n    this.setState({\r\n      chipFocus: null,\r\n      containerFocus: false,\r\n    }, () => this.calculatePosition())\r\n  }\r\n\r\n  handleChipFocus = index => () => {\r\n    this.resetScroll()\r\n    if (!this.props.chipsDisabled) {\r\n      this.setState({\r\n        chipFocus: index,\r\n      }, () => this.calculatePosition())\r\n    }\r\n  }\r\n\r\n  filterOptionsSelected = (options, selected = this.props.selected) => {\r\n    const { fields } = this.props\r\n    const selectedValues = selected.map(item => item[fields.value])\r\n\r\n    return options.filter(option => !selectedValues.includes(option[fields.value]))\r\n  }\r\n\r\n  registerRef = name => (ref) => {\r\n    this[name] = ref\r\n  }\r\n\r\n  calculateChipPosition = () => {\r\n    const containerWidth = this.containerRef.clientWidth\r\n    const { chipFocus, translateX } = this.state\r\n    const ref = this.chipRefs[chipFocus]\r\n\r\n    const pos = this.chipPos(containerWidth, ref.clientWidth, ref.offsetLeft, translateX)\r\n\r\n    if (pos !== null && pos < 0) {\r\n      this.setState({ translateX: pos })\r\n    }\r\n  }\r\n\r\n  chipPos = (containerWidth, chipWidth, chipOffset, translateX) => {\r\n    if (chipOffset + chipWidth > containerWidth + translateX) {\r\n      return -(chipOffset - (containerWidth - chipWidth))\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  alignInput = () => {\r\n    const { offsetLeft, clientWidth } = this.inputContainer\r\n    const containerWidth = this.containerRef.clientWidth\r\n    const translateX = -(offsetLeft - (containerWidth - clientWidth))\r\n    this.setState({ translateX })\r\n  }\r\n\r\n  calculatePosition = () => {\r\n    const { selected } = this.props\r\n    const { chipFocus, inputFocus } = this.state\r\n\r\n    if (selected.length === 0) {\r\n      return this.setState({ translateX: 0 })\r\n    }\r\n\r\n    if (inputFocus) {\r\n      return this.alignInput()\r\n    }\r\n\r\n    if (chipFocus !== null) {\r\n      if (chipFocus === 0) {\r\n        return this.setState({ translateX: 0 })\r\n      }\r\n\r\n      return this.calculateChipPosition()\r\n    }\r\n\r\n    if (!inputFocus && !chipFocus !== null) {\r\n      this.setState({ translateX: 0 })\r\n    }\r\n  }\r\n\r\n  renderChips() {\r\n    const { classes, fields, chipsDisabled, selected } = this.props\r\n    const { chipFocus } = this.state\r\n\r\n    return selected.map((chip, index) => {\r\n      const chipsProps = {\r\n        chip,\r\n        label: chip[fields.label],\r\n        className: cx(classes.chip, index === chipFocus && classes.chipFocus),\r\n        onClick: () => {\r\n          // input need focus before to \"onCopy\" work\r\n          this.input.focus()\r\n          this.focusChip(index)\r\n        },\r\n      }\r\n\r\n      if (!chipsDisabled) {\r\n        chipsProps.onDelete = this.deleteItem(chip)\r\n      }\r\n\r\n      return (\r\n        <div\r\n          ref={(ref) => { this.chipRefs[index] = ref }}\r\n          onFocus={this.handleChipFocus(index)}\r\n          key={`chip-${chip[fields.value]}`}\r\n          className={classes.chipWrapper}\r\n        >\r\n          {this.props.chipComponent(chipsProps)}\r\n        </div>\r\n      )\r\n    })\r\n  }\r\n\r\n  render() {\r\n    const { classes, disabled, selected, label, inputDisabled } = this.props\r\n    const { input, error, containerFocus, chipFocus, optionsOpen, inputFocus } = this.state\r\n    const labelShrinked = (selected.length > 0) || (input.length > 0)\r\n    const labelFocused = containerFocus || chipFocus || inputFocus\r\n\r\n    const formClasses = cx(\r\n      classes.inkbar,\r\n      classes.underline,\r\n      containerFocus && classes.focused,\r\n      error && error.length > 0 && classes.error,\r\n      disabled && classes.disabled,\r\n      classes.formControl\r\n    )\r\n\r\n    return (\r\n      <div\r\n        className={classes.container}\r\n        ref={this.registerRef('containerRef')}\r\n        onFocus={this.handleContainerFocus}\r\n        onBlur={this.handleContainerBlur}\r\n        onKeyPress={this.handleKeyPress}\r\n        tabIndex={-1}\r\n        onPaste={this.handlePaste}\r\n        {...keysWatcher(this.handleKeyDown, this.handleCopy)}\r\n      >\r\n\r\n        <FormControl className={formClasses} error={error && error.length > 0} fullWidth margin=\"dense\">\r\n\r\n          <InputLabel shrink={labelShrinked} margin=\"dense\" focused={labelFocused}>\r\n            {label}\r\n          </InputLabel>\r\n\r\n          <div className={classes.chipsWrapper} ref={this.registerRef('chipsWrapper')}>\r\n            <div className={classes.chips} ref={this.registerRef('chips')} >\r\n\r\n              {this.renderChips()}\r\n\r\n              <div ref={this.registerRef('inputContainer')} className={classes.inputContainer}>\r\n                <Input\r\n                  className={classes.input}\r\n                  onBlur={this.handleInputBlur}\r\n                  onFocus={this.handleInputFocus}\r\n                  onChange={this.handleInputChange}\r\n                  disabled={disabled || inputDisabled}\r\n                  disableUnderline\r\n                  margin=\"dense\"\r\n                  inputRef={this.registerRef('input')}\r\n                  value={input}\r\n                  inputProps={{ spellCheck: false }}\r\n                />\r\n              </div>\r\n\r\n            </div>\r\n          </div>\r\n\r\n          { error &&\r\n            <FormHelperText className={classes.errorText}>\r\n              {error}\r\n            </FormHelperText>\r\n          }\r\n        </FormControl>\r\n\r\n        <this.OptionsComponent\r\n          open={optionsOpen}\r\n          options={this.state.options}\r\n          focus={this.state.optionsFocus}\r\n          onSelect={this.addItemObject}\r\n          fields={this.props.fields}\r\n          optionsClasses={this.props.optionsClasses}\r\n        />\r\n\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default withStyles(styles)(MaterialChips)\r\n\n\n\n// WEBPACK FOOTER //\n// src/MaterialChips/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"material-ui/Input\"\n// module id = 5\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"material-ui/Form\"\n// module id = 6\n// module chunks = 0","/*!\n * Fuse.js v3.2.0 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Fuse\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Fuse\"] = factory();\n\telse\n\t\troot[\"Fuse\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar bitapRegexSearch = __webpack_require__(5);\nvar bitapSearch = __webpack_require__(7);\nvar patternAlphabet = __webpack_require__(4);\n\nvar Bitap = function () {\n  function Bitap(pattern, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$isCaseSensitive = _ref.isCaseSensitive,\n        isCaseSensitive = _ref$isCaseSensitive === undefined ? false : _ref$isCaseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n    _classCallCheck(this, Bitap);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: isCaseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength\n    };\n\n    this.pattern = this.options.isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    if (this.pattern.length <= maxPatternLength) {\n      this.patternAlphabet = patternAlphabet(this.pattern);\n    }\n  }\n\n  _createClass(Bitap, [{\n    key: 'search',\n    value: function search(text) {\n      if (!this.options.isCaseSensitive) {\n        text = text.toLowerCase();\n      }\n\n      // Exact match\n      if (this.pattern === text) {\n        return {\n          isMatch: true,\n          score: 0,\n          matchedIndices: [[0, text.length - 1]]\n        };\n      }\n\n      // When pattern length is greater than the machine word length, just do a a regex comparison\n      var _options = this.options,\n          maxPatternLength = _options.maxPatternLength,\n          tokenSeparator = _options.tokenSeparator;\n\n      if (this.pattern.length > maxPatternLength) {\n        return bitapRegexSearch(text, this.pattern, tokenSeparator);\n      }\n\n      // Otherwise, use Bitap algorithm\n      var _options2 = this.options,\n          location = _options2.location,\n          distance = _options2.distance,\n          threshold = _options2.threshold,\n          findAllMatches = _options2.findAllMatches,\n          minMatchCharLength = _options2.minMatchCharLength;\n\n      return bitapSearch(text, this.pattern, this.patternAlphabet, {\n        location: location,\n        distance: distance,\n        threshold: threshold,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength\n      });\n    }\n  }]);\n\n  return Bitap;\n}();\n\n// let x = new Bitap(\"od mn war\", {})\n// let result = x.search(\"Old Man's War\")\n// console.log(result)\n\nmodule.exports = Bitap;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar isArray = __webpack_require__(0);\n\nvar deepValue = function deepValue(obj, path, list) {\n  if (!path) {\n    // If there's no path left, we've gotten to the object we care about.\n    list.push(obj);\n  } else {\n    var dotIndex = path.indexOf('.');\n    var firstSegment = path;\n    var remaining = null;\n\n    if (dotIndex !== -1) {\n      firstSegment = path.slice(0, dotIndex);\n      remaining = path.slice(dotIndex + 1);\n    }\n\n    var value = obj[firstSegment];\n\n    if (value !== null && value !== undefined) {\n      if (!remaining && (typeof value === 'string' || typeof value === 'number')) {\n        list.push(value.toString());\n      } else if (isArray(value)) {\n        // Search each item in the array.\n        for (var i = 0, len = value.length; i < len; i += 1) {\n          deepValue(value[i], remaining, list);\n        }\n      } else if (remaining) {\n        // An object. Recurse further.\n        deepValue(value, remaining, list);\n      }\n    }\n  }\n\n  return list;\n};\n\nmodule.exports = function (obj, path) {\n  return deepValue(obj, path, []);\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function () {\n  var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var matchedIndices = [];\n  var start = -1;\n  var end = -1;\n  var i = 0;\n\n  for (var len = matchmask.length; i < len; i += 1) {\n    var match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        matchedIndices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    matchedIndices.push([start, i - 1]);\n  }\n\n  return matchedIndices;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern) {\n  var mask = {};\n  var len = pattern.length;\n\n  for (var i = 0; i < len; i += 1) {\n    mask[pattern.charAt(i)] = 0;\n  }\n\n  for (var _i = 0; _i < len; _i += 1) {\n    mask[pattern.charAt(_i)] |= 1 << len - _i - 1;\n  }\n\n  return mask;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar SPECIAL_CHARS_REGEX = /[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;\n\nmodule.exports = function (text, pattern) {\n  var tokenSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : / +/g;\n\n  var regex = new RegExp(pattern.replace(SPECIAL_CHARS_REGEX, '\\\\$&').replace(tokenSeparator, '|'));\n  var matches = text.match(regex);\n  var isMatch = !!matches;\n  var matchedIndices = [];\n\n  if (isMatch) {\n    for (var i = 0, matchesLen = matches.length; i < matchesLen; i += 1) {\n      var match = matches[i];\n      matchedIndices.push([text.indexOf(match), match.length - 1]);\n    }\n  }\n\n  return {\n    // TODO: revisit this score\n    score: isMatch ? 0.5 : 1,\n    isMatch: isMatch,\n    matchedIndices: matchedIndices\n  };\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (pattern, _ref) {\n  var _ref$errors = _ref.errors,\n      errors = _ref$errors === undefined ? 0 : _ref$errors,\n      _ref$currentLocation = _ref.currentLocation,\n      currentLocation = _ref$currentLocation === undefined ? 0 : _ref$currentLocation,\n      _ref$expectedLocation = _ref.expectedLocation,\n      expectedLocation = _ref$expectedLocation === undefined ? 0 : _ref$expectedLocation,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance;\n\n  var accuracy = errors / pattern.length;\n  var proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy;\n  }\n\n  return accuracy + proximity / distance;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bitapScore = __webpack_require__(6);\nvar matchedIndices = __webpack_require__(3);\n\nmodule.exports = function (text, pattern, patternAlphabet, _ref) {\n  var _ref$location = _ref.location,\n      location = _ref$location === undefined ? 0 : _ref$location,\n      _ref$distance = _ref.distance,\n      distance = _ref$distance === undefined ? 100 : _ref$distance,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n      _ref$findAllMatches = _ref.findAllMatches,\n      findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n      _ref$minMatchCharLeng = _ref.minMatchCharLength,\n      minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng;\n\n  var expectedLocation = location;\n  // Set starting location at beginning text and initialize the alphabet.\n  var textLen = text.length;\n  // Highest score beyond which we give up.\n  var currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  var bestLocation = text.indexOf(pattern, expectedLocation);\n\n  var patternLen = pattern.length;\n\n  // a mask of the matches\n  var matchMask = [];\n  for (var i = 0; i < textLen; i += 1) {\n    matchMask[i] = 0;\n  }\n\n  if (bestLocation !== -1) {\n    var score = bitapScore(pattern, {\n      errors: 0,\n      currentLocation: bestLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n    currentThreshold = Math.min(score, currentThreshold);\n\n    // What about in the other direction? (speed up)\n    bestLocation = text.lastIndexOf(pattern, expectedLocation + patternLen);\n\n    if (bestLocation !== -1) {\n      var _score = bitapScore(pattern, {\n        errors: 0,\n        currentLocation: bestLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n      currentThreshold = Math.min(_score, currentThreshold);\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  var lastBitArr = [];\n  var finalScore = 1;\n  var binMax = patternLen + textLen;\n\n  var mask = 1 << patternLen - 1;\n\n  for (var _i = 0; _i < patternLen; _i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    var binMin = 0;\n    var binMid = binMax;\n\n    while (binMin < binMid) {\n      var _score3 = bitapScore(pattern, {\n        errors: _i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score3 <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    var start = Math.max(1, expectedLocation - binMid + 1);\n    var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    var bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << _i) - 1;\n\n    for (var j = finish; j >= start; j -= 1) {\n      var currentLocation = j - 1;\n      var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (charMatch) {\n        matchMask[currentLocation] = 1;\n      }\n\n      // First pass: exact match\n      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (_i !== 0) {\n        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = bitapScore(pattern, {\n          errors: _i,\n          currentLocation: currentLocation,\n          expectedLocation: expectedLocation,\n          distance: distance\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break;\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    var _score2 = bitapScore(pattern, {\n      errors: _i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation: expectedLocation,\n      distance: distance\n    });\n\n    if (_score2 > currentThreshold) {\n      break;\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  // Count exact matches (those with a score of 0) to be \"almost\" exact\n  return {\n    isMatch: bestLocation >= 0,\n    score: finalScore === 0 ? 0.001 : finalScore,\n    matchedIndices: matchedIndices(matchMask, minMatchCharLength)\n  };\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Bitap = __webpack_require__(1);\nvar deepValue = __webpack_require__(2);\nvar isArray = __webpack_require__(0);\n\nvar Fuse = function () {\n  function Fuse(list, _ref) {\n    var _ref$location = _ref.location,\n        location = _ref$location === undefined ? 0 : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === undefined ? 100 : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === undefined ? 0.6 : _ref$threshold,\n        _ref$maxPatternLength = _ref.maxPatternLength,\n        maxPatternLength = _ref$maxPatternLength === undefined ? 32 : _ref$maxPatternLength,\n        _ref$caseSensitive = _ref.caseSensitive,\n        caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n        _ref$tokenSeparator = _ref.tokenSeparator,\n        tokenSeparator = _ref$tokenSeparator === undefined ? / +/g : _ref$tokenSeparator,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === undefined ? false : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === undefined ? 1 : _ref$minMatchCharLeng,\n        _ref$id = _ref.id,\n        id = _ref$id === undefined ? null : _ref$id,\n        _ref$keys = _ref.keys,\n        keys = _ref$keys === undefined ? [] : _ref$keys,\n        _ref$shouldSort = _ref.shouldSort,\n        shouldSort = _ref$shouldSort === undefined ? true : _ref$shouldSort,\n        _ref$getFn = _ref.getFn,\n        getFn = _ref$getFn === undefined ? deepValue : _ref$getFn,\n        _ref$sortFn = _ref.sortFn,\n        sortFn = _ref$sortFn === undefined ? function (a, b) {\n      return a.score - b.score;\n    } : _ref$sortFn,\n        _ref$tokenize = _ref.tokenize,\n        tokenize = _ref$tokenize === undefined ? false : _ref$tokenize,\n        _ref$matchAllTokens = _ref.matchAllTokens,\n        matchAllTokens = _ref$matchAllTokens === undefined ? false : _ref$matchAllTokens,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === undefined ? false : _ref$includeMatches,\n        _ref$includeScore = _ref.includeScore,\n        includeScore = _ref$includeScore === undefined ? false : _ref$includeScore,\n        _ref$verbose = _ref.verbose,\n        verbose = _ref$verbose === undefined ? false : _ref$verbose;\n\n    _classCallCheck(this, Fuse);\n\n    this.options = {\n      location: location,\n      distance: distance,\n      threshold: threshold,\n      maxPatternLength: maxPatternLength,\n      isCaseSensitive: caseSensitive,\n      tokenSeparator: tokenSeparator,\n      findAllMatches: findAllMatches,\n      minMatchCharLength: minMatchCharLength,\n      id: id,\n      keys: keys,\n      includeMatches: includeMatches,\n      includeScore: includeScore,\n      shouldSort: shouldSort,\n      getFn: getFn,\n      sortFn: sortFn,\n      verbose: verbose,\n      tokenize: tokenize,\n      matchAllTokens: matchAllTokens\n    };\n\n    this.setCollection(list);\n  }\n\n  _createClass(Fuse, [{\n    key: 'setCollection',\n    value: function setCollection(list) {\n      this.list = list;\n      return list;\n    }\n  }, {\n    key: 'search',\n    value: function search(pattern) {\n      this._log('---------\\nSearch pattern: \"' + pattern + '\"');\n\n      var _prepareSearchers2 = this._prepareSearchers(pattern),\n          tokenSearchers = _prepareSearchers2.tokenSearchers,\n          fullSearcher = _prepareSearchers2.fullSearcher;\n\n      var _search2 = this._search(tokenSearchers, fullSearcher),\n          weights = _search2.weights,\n          results = _search2.results;\n\n      this._computeScore(weights, results);\n\n      if (this.options.shouldSort) {\n        this._sort(results);\n      }\n\n      return this._format(results);\n    }\n  }, {\n    key: '_prepareSearchers',\n    value: function _prepareSearchers() {\n      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      var tokenSearchers = [];\n\n      if (this.options.tokenize) {\n        // Tokenize on the separator\n        var tokens = pattern.split(this.options.tokenSeparator);\n        for (var i = 0, len = tokens.length; i < len; i += 1) {\n          tokenSearchers.push(new Bitap(tokens[i], this.options));\n        }\n      }\n\n      var fullSearcher = new Bitap(pattern, this.options);\n\n      return { tokenSearchers: tokenSearchers, fullSearcher: fullSearcher };\n    }\n  }, {\n    key: '_search',\n    value: function _search() {\n      var tokenSearchers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var fullSearcher = arguments[1];\n\n      var list = this.list;\n      var resultMap = {};\n      var results = [];\n\n      // Check the first item in the list, if it's a string, then we assume\n      // that every item in the list is also a string, and thus it's a flattened array.\n      if (typeof list[0] === 'string') {\n        // Iterate over every item\n        for (var i = 0, len = list.length; i < len; i += 1) {\n          this._analyze({\n            key: '',\n            value: list[i],\n            record: i,\n            index: i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n\n        return { weights: null, results: results };\n      }\n\n      // Otherwise, the first item is an Object (hopefully), and thus the searching\n      // is done on the values of the keys of each item.\n      var weights = {};\n      for (var _i = 0, _len = list.length; _i < _len; _i += 1) {\n        var item = list[_i];\n        // Iterate over every key\n        for (var j = 0, keysLen = this.options.keys.length; j < keysLen; j += 1) {\n          var key = this.options.keys[j];\n          if (typeof key !== 'string') {\n            weights[key.name] = {\n              weight: 1 - key.weight || 1\n            };\n            if (key.weight <= 0 || key.weight > 1) {\n              throw new Error('Key weight has to be > 0 and <= 1');\n            }\n            key = key.name;\n          } else {\n            weights[key] = {\n              weight: 1\n            };\n          }\n\n          this._analyze({\n            key: key,\n            value: this.options.getFn(item, key),\n            record: item,\n            index: _i\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n\n      return { weights: weights, results: results };\n    }\n  }, {\n    key: '_analyze',\n    value: function _analyze(_ref2, _ref3) {\n      var key = _ref2.key,\n          _ref2$arrayIndex = _ref2.arrayIndex,\n          arrayIndex = _ref2$arrayIndex === undefined ? -1 : _ref2$arrayIndex,\n          value = _ref2.value,\n          record = _ref2.record,\n          index = _ref2.index;\n      var _ref3$tokenSearchers = _ref3.tokenSearchers,\n          tokenSearchers = _ref3$tokenSearchers === undefined ? [] : _ref3$tokenSearchers,\n          _ref3$fullSearcher = _ref3.fullSearcher,\n          fullSearcher = _ref3$fullSearcher === undefined ? [] : _ref3$fullSearcher,\n          _ref3$resultMap = _ref3.resultMap,\n          resultMap = _ref3$resultMap === undefined ? {} : _ref3$resultMap,\n          _ref3$results = _ref3.results,\n          results = _ref3$results === undefined ? [] : _ref3$results;\n\n      // Check if the texvaluet can be searched\n      if (value === undefined || value === null) {\n        return;\n      }\n\n      var exists = false;\n      var averageScore = -1;\n      var numTextMatches = 0;\n\n      if (typeof value === 'string') {\n        this._log('\\nKey: ' + (key === '' ? '-' : key));\n\n        var mainSearchResult = fullSearcher.search(value);\n        this._log('Full text: \"' + value + '\", score: ' + mainSearchResult.score);\n\n        if (this.options.tokenize) {\n          var words = value.split(this.options.tokenSeparator);\n          var scores = [];\n\n          for (var i = 0; i < tokenSearchers.length; i += 1) {\n            var tokenSearcher = tokenSearchers[i];\n\n            this._log('\\nPattern: \"' + tokenSearcher.pattern + '\"');\n\n            // let tokenScores = []\n            var hasMatchInText = false;\n\n            for (var j = 0; j < words.length; j += 1) {\n              var word = words[j];\n              var tokenSearchResult = tokenSearcher.search(word);\n              var obj = {};\n              if (tokenSearchResult.isMatch) {\n                obj[word] = tokenSearchResult.score;\n                exists = true;\n                hasMatchInText = true;\n                scores.push(tokenSearchResult.score);\n              } else {\n                obj[word] = 1;\n                if (!this.options.matchAllTokens) {\n                  scores.push(1);\n                }\n              }\n              this._log('Token: \"' + word + '\", score: ' + obj[word]);\n              // tokenScores.push(obj)\n            }\n\n            if (hasMatchInText) {\n              numTextMatches += 1;\n            }\n          }\n\n          averageScore = scores[0];\n          var scoresLen = scores.length;\n          for (var _i2 = 1; _i2 < scoresLen; _i2 += 1) {\n            averageScore += scores[_i2];\n          }\n          averageScore = averageScore / scoresLen;\n\n          this._log('Token score average:', averageScore);\n        }\n\n        var finalScore = mainSearchResult.score;\n        if (averageScore > -1) {\n          finalScore = (finalScore + averageScore) / 2;\n        }\n\n        this._log('Score average:', finalScore);\n\n        var checkTextMatches = this.options.tokenize && this.options.matchAllTokens ? numTextMatches >= tokenSearchers.length : true;\n\n        this._log('\\nCheck Matches: ' + checkTextMatches);\n\n        // If a match is found, add the item to <rawResults>, including its score\n        if ((exists || mainSearchResult.isMatch) && checkTextMatches) {\n          // Check if the item already exists in our results\n          var existingResult = resultMap[index];\n          if (existingResult) {\n            // Use the lowest score\n            // existingResult.score, bitapResult.score\n            existingResult.output.push({\n              key: key,\n              arrayIndex: arrayIndex,\n              value: value,\n              score: finalScore,\n              matchedIndices: mainSearchResult.matchedIndices\n            });\n          } else {\n            // Add it to the raw result list\n            resultMap[index] = {\n              item: record,\n              output: [{\n                key: key,\n                arrayIndex: arrayIndex,\n                value: value,\n                score: finalScore,\n                matchedIndices: mainSearchResult.matchedIndices\n              }]\n            };\n\n            results.push(resultMap[index]);\n          }\n        }\n      } else if (isArray(value)) {\n        for (var _i3 = 0, len = value.length; _i3 < len; _i3 += 1) {\n          this._analyze({\n            key: key,\n            arrayIndex: _i3,\n            value: value[_i3],\n            record: record,\n            index: index\n          }, {\n            resultMap: resultMap,\n            results: results,\n            tokenSearchers: tokenSearchers,\n            fullSearcher: fullSearcher\n          });\n        }\n      }\n    }\n  }, {\n    key: '_computeScore',\n    value: function _computeScore(weights, results) {\n      this._log('\\n\\nComputing score:\\n');\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var output = results[i].output;\n        var scoreLen = output.length;\n\n        var totalScore = 0;\n        var bestScore = 1;\n\n        for (var j = 0; j < scoreLen; j += 1) {\n          var weight = weights ? weights[output[j].key].weight : 1;\n          var score = weight === 1 ? output[j].score : output[j].score || 0.001;\n          var nScore = score * weight;\n\n          if (weight !== 1) {\n            bestScore = Math.min(bestScore, nScore);\n          } else {\n            output[j].nScore = nScore;\n            totalScore += nScore;\n          }\n        }\n\n        results[i].score = bestScore === 1 ? totalScore / scoreLen : bestScore;\n\n        this._log(results[i]);\n      }\n    }\n  }, {\n    key: '_sort',\n    value: function _sort(results) {\n      this._log('\\n\\nSorting....');\n      results.sort(this.options.sortFn);\n    }\n  }, {\n    key: '_format',\n    value: function _format(results) {\n      var finalOutput = [];\n\n      this._log('\\n\\nOutput:\\n\\n', JSON.stringify(results));\n\n      var transformers = [];\n\n      if (this.options.includeMatches) {\n        transformers.push(function (result, data) {\n          var output = result.output;\n          data.matches = [];\n\n          for (var i = 0, len = output.length; i < len; i += 1) {\n            var item = output[i];\n\n            if (item.matchedIndices.length === 0) {\n              continue;\n            }\n\n            var obj = {\n              indices: item.matchedIndices,\n              value: item.value\n            };\n            if (item.key) {\n              obj.key = item.key;\n            }\n            if (item.hasOwnProperty('arrayIndex') && item.arrayIndex > -1) {\n              obj.arrayIndex = item.arrayIndex;\n            }\n            data.matches.push(obj);\n          }\n        });\n      }\n\n      if (this.options.includeScore) {\n        transformers.push(function (result, data) {\n          data.score = result.score;\n        });\n      }\n\n      for (var i = 0, len = results.length; i < len; i += 1) {\n        var result = results[i];\n\n        if (this.options.id) {\n          result.item = this.options.getFn(result.item, this.options.id)[0];\n        }\n\n        if (!transformers.length) {\n          finalOutput.push(result.item);\n          continue;\n        }\n\n        var data = {\n          item: result.item\n        };\n\n        for (var j = 0, _len2 = transformers.length; j < _len2; j += 1) {\n          transformers[j](result, data);\n        }\n\n        finalOutput.push(data);\n      }\n\n      return finalOutput;\n    }\n  }, {\n    key: '_log',\n    value: function _log() {\n      if (this.options.verbose) {\n        var _console;\n\n        (_console = console).log.apply(_console, arguments);\n      }\n    }\n  }]);\n\n  return Fuse;\n}();\n\nmodule.exports = Fuse;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=fuse.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fuse.js/dist/fuse.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nvar deselectCurrent = require('toggle-selection');\n\nvar defaultMessage = 'Copy to clipboard: #{key}, Enter';\n\nfunction format(message) {\n  var copyKey = (/mac os x/i.test(navigator.userAgent) ? '⌘' : 'Ctrl') + '+C';\n  return message.replace(/#{\\s*key\\s*}/g, copyKey);\n}\n\nfunction copy(text, options) {\n  var debug, message, reselectPrevious, range, selection, mark, success = false;\n  if (!options) { options = {}; }\n  debug = options.debug || false;\n  try {\n    reselectPrevious = deselectCurrent();\n\n    range = document.createRange();\n    selection = document.getSelection();\n\n    mark = document.createElement('span');\n    mark.textContent = text;\n    // reset user styles for span element\n    mark.style.all = 'unset';\n    // prevents scrolling to the end of the page\n    mark.style.position = 'fixed';\n    mark.style.top = 0;\n    mark.style.clip = 'rect(0, 0, 0, 0)';\n    // used to preserve spaces and line breaks\n    mark.style.whiteSpace = 'pre';\n    // do not inherit user-select (it may be `none`)\n    mark.style.webkitUserSelect = 'text';\n    mark.style.MozUserSelect = 'text';\n    mark.style.msUserSelect = 'text';\n    mark.style.userSelect = 'text';\n\n    document.body.appendChild(mark);\n\n    range.selectNode(mark);\n    selection.addRange(range);\n\n    var successful = document.execCommand('copy');\n    if (!successful) {\n      throw new Error('copy command was unsuccessful');\n    }\n    success = true;\n  } catch (err) {\n    debug && console.error('unable to copy using execCommand: ', err);\n    debug && console.warn('trying IE specific stuff');\n    try {\n      window.clipboardData.setData('text', text);\n      success = true;\n    } catch (err) {\n      debug && console.error('unable to copy using clipboardData: ', err);\n      debug && console.error('falling back to prompt');\n      message = format('message' in options ? options.message : defaultMessage);\n      window.prompt(message, text);\n    }\n  } finally {\n    if (selection) {\n      if (typeof selection.removeRange == 'function') {\n        selection.removeRange(range);\n      } else {\n        selection.removeAllRanges();\n      }\n    }\n\n    if (mark) {\n      document.body.removeChild(mark);\n    }\n    reselectPrevious();\n  }\n\n  return success;\n}\n\nmodule.exports = copy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/copy-to-clipboard/index.js\n// module id = 8\n// module chunks = 0","\nmodule.exports = function () {\n  var selection = document.getSelection();\n  if (!selection.rangeCount) {\n    return function () {};\n  }\n  var active = document.activeElement;\n\n  var ranges = [];\n  for (var i = 0; i < selection.rangeCount; i++) {\n    ranges.push(selection.getRangeAt(i));\n  }\n\n  switch (active.tagName.toUpperCase()) { // .toUpperCase handles XHTML\n    case 'INPUT':\n    case 'TEXTAREA':\n      active.blur();\n      break;\n\n    default:\n      active = null;\n      break;\n  }\n\n  selection.removeAllRanges();\n  return function () {\n    selection.type === 'Caret' &&\n    selection.removeAllRanges();\n\n    if (!selection.rangeCount) {\n      ranges.forEach(function(range) {\n        selection.addRange(range);\n      });\n    }\n\n    active &&\n    active.focus();\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/toggle-selection/index.js\n// module id = 9\n// module chunks = 0","import React from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport Chip from 'material-ui/Chip'\r\n\r\n\r\nfunction ChipComponent(props) {\r\n  const chipProps = Object.assign({}, props)\r\n  delete chipProps.chip\r\n\r\n  return (\r\n    <Chip\r\n      {...chipProps}\r\n    />\r\n  )\r\n}\r\n\r\nChipComponent.propTypes = {\r\n  label: PropTypes.string,\r\n  className: PropTypes.string,\r\n  onDelete: PropTypes.func,\r\n  chip: PropTypes.object,\r\n}\r\n\r\nexport default ChipComponent\r\n\n\n\n// WEBPACK FOOTER //\n// src/MaterialChips/Chip.js","module.exports = __WEBPACK_EXTERNAL_MODULE_11__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"material-ui/Chip\"\n// module id = 11\n// module chunks = 0","import React from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport cx from 'classnames'\r\nimport Paper from 'material-ui/Paper'\r\nimport { MenuItem } from 'material-ui/Menu'\r\nimport { withStyles } from 'material-ui/styles'\r\nimport deepmerge from 'deepmerge'\r\n\r\nconst styles = theme => ({\r\n  optionsContainer: {\r\n    display: 'none',\r\n    maxHeight: 300,\r\n    overflowY: 'auto',\r\n  },\r\n  optionsContainerOpen: {\r\n    position: 'absolute',\r\n    display: 'block',\r\n    zIndex: 90,\r\n    marginBottom: theme.spacing.unit * 3,\r\n    left: 0,\r\n    top: '100%',\r\n    right: 0,\r\n  },\r\n})\r\n\r\nfunction addBold(start, end, str) {\r\n  return `${str.slice(0, start)}<b>${str.slice(start, end + 1)}</b>${str.slice(end + 1, str.length)}`\r\n}\r\n\r\nfunction showLabel({ item, matches }, { label }) {\r\n  const match = matches.find(i => i.key === label)\r\n\r\n  if (match) {\r\n    return match.indices.reduce((acc, curr) => {\r\n      acc.result = addBold(curr[0] + acc.count, curr[1] + acc.count, acc.result)\r\n      acc.count += 7\r\n\r\n      return acc\r\n    }, { count: 0, result: match.value }).result\r\n  }\r\n\r\n  return item[label]\r\n}\r\n\r\nconst Options = ({ classes, open, options, onSelect, fields, focus }) => {\r\n  const containerOpen = open && options.length > 0\r\n  const containerClasses = cx(\r\n    classes.optionsContainer,\r\n    containerOpen && classes.optionsContainerOpen\r\n  )\r\n\r\n  return (\r\n    <Paper className={containerClasses} square>\r\n      {options.map((item, index) => {\r\n        const option = item.item\r\n        return (\r\n          <MenuItem\r\n            key={option.label + option.value}\r\n            onClick={() => onSelect(option)}\r\n            classes={{\r\n              root: classes.menuItemRoot,\r\n              selected: classes.menuItemSelected,\r\n            }}\r\n            selected={focus === index}\r\n          >\r\n            <span\r\n              dangerouslySetInnerHTML={{ __html: showLabel(item, fields) }} // eslint-disable-line\r\n            />\r\n          </MenuItem>\r\n        )\r\n      })}\r\n    </Paper>\r\n  )\r\n}\r\n\r\nOptions.propTypes = {\r\n  classes: PropTypes.object,\r\n  open: PropTypes.bool,\r\n  options: PropTypes.arrayOf(PropTypes.object),\r\n  onSelect: PropTypes.func,\r\n  fields: PropTypes.object,\r\n  focus: PropTypes.number,\r\n}\r\n\r\nexport default (customStyles) => {\r\n  if (customStyles) {\r\n    return withStyles(theme => deepmerge(styles(theme), customStyles(theme)))(Options)\r\n  }\r\n\r\n  return withStyles(styles)(Options)\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/MaterialChips/Options.js","module.exports = __WEBPACK_EXTERNAL_MODULE_13__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"material-ui/Paper\"\n// module id = 13\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"material-ui/Menu\"\n// module id = 14\n// module chunks = 0","var isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, optionsArgument) {\n\tvar clone = !optionsArgument || optionsArgument.clone !== false;\n\n\treturn (clone && isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, optionsArgument)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, optionsArgument) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, optionsArgument)\n\t})\n}\n\nfunction mergeObject(target, source, optionsArgument) {\n\tvar destination = {};\n\tif (isMergeableObject(target)) {\n\t\tObject.keys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument);\n\t\t});\n\t}\n\tObject.keys(source).forEach(function(key) {\n\t\tif (!isMergeableObject(source[key]) || !target[key]) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument);\n\t\t} else {\n\t\t\tdestination[key] = deepmerge(target[key], source[key], optionsArgument);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, optionsArgument) {\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar options = optionsArgument || { arrayMerge: defaultArrayMerge };\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, optionsArgument)\n\t} else if (sourceIsArray) {\n\t\tvar arrayMerge = options.arrayMerge || defaultArrayMerge;\n\t\treturn arrayMerge(target, source, optionsArgument)\n\t} else {\n\t\treturn mergeObject(target, source, optionsArgument)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, optionsArgument) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, optionsArgument)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nexport default deepmerge_1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/deepmerge/dist/es.js\n// module id = 15\n// module chunks = 0","export const TYPES = {\r\n  ESCAPE: [27],\r\n  LEFT: [37],\r\n  RIGHT: [39],\r\n  CTRL: [17],\r\n  C: [67],\r\n  UP: [38],\r\n  DOWN: [40],\r\n  BACKSPACE: [8],\r\n  TAB: [9],\r\n  DELETE_CODES: [46, 8],\r\n}\r\n\r\nexport function acceptedCharCodes(code) {\r\n  return code > 64 && code < 123\r\n}\r\n\r\nexport function validate(value, validators, selected) {\r\n  if (!validators || validators.length === 0) {\r\n    return false\r\n  }\r\n\r\n  return validators.reduce((acc, curr) => {\r\n    if (!acc && curr.validator(value, selected)) {\r\n      return curr.message\r\n    }\r\n\r\n    return acc\r\n  }, false)\r\n}\r\n\r\n\r\nexport function mimicFuseSearch(options) {\r\n  return options.map(option => ({\r\n    matches: [],\r\n    item: option,\r\n  }))\r\n}\r\n\r\nexport function keysWatcher(handleKeyDown, handleCopy) {\r\n  let ctrlPressed = false\r\n\r\n  return {\r\n    onKeyDown(e) {\r\n      if (TYPES.CTRL.includes(e.keyCode)) {\r\n        ctrlPressed = true\r\n      }\r\n\r\n      if (ctrlPressed && TYPES.C.includes(e.keyCode)) {\r\n        handleCopy(e)\r\n      }\r\n\r\n      handleKeyDown(e)\r\n    },\r\n    onKeyUp(e) {\r\n      if (TYPES.CTRL.includes(e.keyCode)) {\r\n        ctrlPressed = false\r\n      }\r\n    },\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/MaterialChips/helpers.js","const styles = theme => ({\r\n  container: {\r\n    position: 'relative',\r\n    width: '100%',\r\n    '&:focus': {\r\n      outline: 'none',\r\n    },\r\n  },\r\n  formControl: {\r\n    transition: '.3s ease',\r\n    display: 'flex',\r\n    marginBottom: theme.spacing.unit / 2,\r\n  },\r\n  inputContainer: {\r\n    display: 'inline-flex',\r\n    flex: '1 0 auto',\r\n  },\r\n  chipsWrapper: {\r\n    position: 'relative',\r\n    flex: '1 0 auto',\r\n  },\r\n  chips: {\r\n    position: 'relative',\r\n    minWidth: '100%',\r\n    flexWrap: 'wrap',\r\n    marginTop: 15,\r\n    transition: '.3s ease',\r\n    display: 'inline-flex',\r\n  },\r\n  chipFocus: {\r\n    '&$chip > svg': {\r\n      color: theme.palette.primary[500],\r\n    },\r\n  },\r\n  chip: {\r\n    display: 'inline-flex',\r\n    height: 20,\r\n    padding: 4,\r\n    margin: theme.spacing.unit / 4,\r\n    '&:hover:not($chipFocus) > svg': {\r\n      color: theme.palette.primary[400],\r\n      '&:hover': {\r\n        color: theme.palette.primary[500],\r\n      },\r\n    },\r\n    '& > svg': {\r\n      color: theme.palette.grey[700],\r\n      width: 16,\r\n    },\r\n  },\r\n  error: {\r\n    marginBottom: theme.spacing.unit * 3,\r\n  },\r\n  errorText: {\r\n    position: 'absolute',\r\n    bottom: -15,\r\n  },\r\n  chipWrapper: {\r\n    display: 'inline-flex',\r\n    '&:last-child': {\r\n      marginRight: (theme.spacing.unit / 3) * 2,\r\n    },\r\n  },\r\n  input: {\r\n    paddingTop: 2,\r\n    fontSize: 13,\r\n    flex: '1 0 auto',\r\n  },\r\n  disabled: {\r\n    color: theme.palette.text.disabled,\r\n  },\r\n  inkbar: {\r\n    '&:after': {\r\n      backgroundColor: theme.palette.primary[theme.palette.type === 'light' ? 'A700' : 'A200'],\r\n      left: 0,\r\n      bottom: 0,\r\n      // Doing the other way around crash on IE11 \"''\" https://github.com/cssinjs/jss/issues/242\r\n      content: '\"\"',\r\n      height: 2,\r\n      position: 'absolute',\r\n      right: 0,\r\n      transform: 'scaleX(0)',\r\n      transition: theme.transitions.create('transform', {\r\n        duration: theme.transitions.duration.shorter,\r\n        easing: theme.transitions.easing.easeOut,\r\n      }),\r\n    },\r\n    '&$error:after': {\r\n      backgroundColor: theme.palette.error.A400,\r\n    },\r\n    '&$focused:after': {\r\n      transform: 'scaleX(1)',\r\n    },\r\n  },\r\n  focused: {},\r\n  underline: {\r\n    '&:before': {\r\n      backgroundColor: theme.palette.input.bottomLine,\r\n      left: 0,\r\n      bottom: 0,\r\n      // Doing the other way around crash on IE11 \"''\" https://github.com/cssinjs/jss/issues/242\r\n      content: '\"\"',\r\n      height: 1,\r\n      position: 'absolute',\r\n      right: 0,\r\n      transition: theme.transitions.create('background-color', {\r\n        duration: theme.transitions.duration.shorter,\r\n        easing: theme.transitions.easing.ease,\r\n      }),\r\n    },\r\n    '&:hover:not($disabled):before': {\r\n      backgroundColor: theme.palette.text.primary,\r\n      height: 2,\r\n    },\r\n    '&$error:before': {\r\n      backgroundColor: theme.palette.error.A400,\r\n      transform: 'scaleX(1)', // error is always underlined in red\r\n    },\r\n    '&$disabled:before': {\r\n      background: 'transparent',\r\n      backgroundImage: `linear-gradient(to right, ${theme.palette.input\r\n        .bottomLine} 33%, transparent 0%)`,\r\n      backgroundPosition: 'left top',\r\n      backgroundRepeat: 'repeat-x',\r\n      backgroundSize: '5px 1px',\r\n    },\r\n  },\r\n})\r\n\r\nexport default styles\r\n\n\n\n// WEBPACK FOOTER //\n// src/MaterialChips/styles.js"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;;;ACAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AACA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;AAEA;;;;;;AAMA;;;;;;;;;;;;;;AA6EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AA+BA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAKA;AADA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AACA;AAYA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AADA;AAAA;AAAA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAFA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAAA;AAKA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AAEA;AAVA;AAaA;AACA;AAAA;AACA;AACA;AAFA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAFA;AAGA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AAAA;AACA;AACA;AAPA;AASA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AADA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AArcA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAoIA;;;;;AAqCA;AACA;;;AA2QA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAJA;AAMA;AANA;AASA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAWA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AADA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AADA;AAJA;AADA;AAuBA;AACA;AAAA;AACA;AADA;AA9BA;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AA/CA;AA0DA;;;;;;AA1oBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAzDA;AADA;AAgEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAXA;AA8kBA;;;;;;AClqBA;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACn+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtCA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;;;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;;;;;;ACvBA;;;;;;;;;;;;;ACAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AANA;AAAA;AACA;AAgBA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AAPA;AASA;AACA;AADA;AATA;AAcA;AAlBA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;AC1FA;;;;;;ACAA;;;;;;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3EA;AAIA;AAeA;AAOA;AAvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAFA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;;;;;;;;;;;;AC5DA;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;AAHA;AAOA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AADA;AADA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAFA;AAMA;AACA;AACA;AAFA;AAXA;AAgBA;AACA;AADA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AADA;AAFA;AAMA;AACA;AACA;AACA;AAHA;AAKA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAVA;AAeA;AACA;AADA;AAGA;AACA;AADA;AAnBA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AATA;AAcA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAEA;AACA;AACA;AANA;AAvBA;AA/FA;AAAA;AACA;AAgIA;;;;A","sourceRoot":""}